<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Uno Com Escada Simulator 95</title>
  <script type="module" crossorigin>
var C=Object.defineProperty;var G=(i,t,e)=>t in i?C(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e;var n=(i,t,e)=>(G(i,typeof t!="symbol"?t+"":t,e),e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))o(s);new MutationObserver(s=>{for(const r of s)if(r.type==="childList")for(const h of r.addedNodes)h.tagName==="LINK"&&h.rel==="modulepreload"&&o(h)}).observe(document,{childList:!0,subtree:!0});function e(s){const r={};return s.integrity&&(r.integrity=s.integrity),s.referrerPolicy&&(r.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?r.credentials="include":s.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function o(s){if(s.ep)return;s.ep=!0;const r=e(s);fetch(s.href,r)}})();const N=12,O=8;class x{constructor({center:t,radius:e,from:o,to:s,prev:r,width:h}){n(this,"center");n(this,"radius");n(this,"from");n(this,"to");n(this,"prev");n(this,"next");n(this,"width");n(this,"length",0);n(this,"segments",0);n(this,"vertices",[]);n(this,"aabb",[]);n(this,"waypoints",[]);n(this,"clockwise",!0);for(s<0&&(this.clockwise=!1);o>2;)o-=2;for(;o<0;)o+=2;this.center=t,this.radius=e,this.from=o,this.to=s,this.prev=r,this.length=this.radius*Math.abs(this.to)*Math.PI,this.segments=Math.max(4,this.length/N|0),this.width=h,this.generateWaypoints(),this.aabb=this.getAABB()}generateWaypoints(){const t=Math.max(2,this.length/O|0),e=this.to/t;this.waypoints.push(this.startPoint);const[o,s]=this.center;for(let r=1;r<t;r++)console.log("mais um"),this.waypoints.push([o+Math.cos((this.from+e*r)*Math.PI)*this.radius,s+Math.sin((this.from+e*r)*Math.PI)*this.radius]);this.waypoints.push(this.endPoint)}get endPoint(){const[t,e]=this.center,o=t+this.radius*Math.cos((this.from+this.to)*Math.PI),s=e+this.radius*Math.sin((this.from+this.to)*Math.PI);return[o,s]}get endPointLeft(){const[t,e]=this.center;return[t+(this.radius+this.width/2)*Math.cos((this.from+this.to)*Math.PI),e+(this.radius+this.width/2)*Math.sin((this.from+this.to)*Math.PI)]}get endPointRight(){const[t,e]=this.center;return[t+(this.radius-this.width/2)*Math.cos((this.from+this.to)*Math.PI),e+(this.radius-this.width/2)*Math.sin((this.from+this.to)*Math.PI)]}get startPoint(){const[t,e]=this.center,o=t+this.radius*Math.cos(this.from*Math.PI),s=e+this.radius*Math.sin(this.from*Math.PI);return[o,s]}get startPointLeft(){const[t,e]=this.center;return[t+(this.radius+this.width/2)*Math.cos(this.from*Math.PI),e+(this.radius+this.width/2)*Math.sin(this.from*Math.PI)]}get startPointRight(){const[t,e]=this.center;return[t+(this.radius-this.width/2)*Math.cos(this.from*Math.PI),e+(this.radius-this.width/2)*Math.sin(this.from*Math.PI)]}getAABB(){const t=[this.startPointLeft,this.startPointRight,this.endPointLeft,this.endPointRight];let e=t[0][0],o=t[0][1],s=t[0][0],r=t[0][1];for(const h of t)h[0]<e&&(e=h[0]),h[0]>s&&(s=h[0]),h[1]<o&&(o=h[1]),h[1]>r&&(r=h[1]);return[e,o,s-e,r-o]}closestPoint(t,e){const o=t-this.center[0],s=e-this.center[1],r=Math.atan2(s,o);return[this.center[0]+this.radius*Math.cos(r),this.center[1]+this.radius*Math.sin(r)]}lookAhead(t,e){let o=t-this.center[0],s=e-this.center[1];const r=Math.sqrt(o*o+s*s);return o/=r,s/=r,this.to<0&&(o*=-1,s*=-1),[-s,o]}continue({radius:t,to:e}){const o=Math.cos((this.from+this.to)*Math.PI),s=Math.sin((this.from+this.to)*Math.PI),r=[this.center[0]+o*(this.radius+(Math.sign(this.to)!==Math.sign(e)?t:-t)),this.center[1]+s*(this.radius+(Math.sign(this.to)!==Math.sign(e)?t:-t))];let h=this.from+this.to,g=e;Math.sign(this.to)!==Math.sign(e)&&(h+=1);const d=new x({center:r,radius:t,from:h,to:g,prev:this,width:this.width});return this.next=d,d}draw(t,e){const[o,s]=this.center,r=this.to*Math.PI/this.segments,h=this.from*Math.PI;let g=[[-this.width/2,"red"],[this.width/2,"green"]];this.clockwise||(g=[[-this.width/2,"green"],[this.width/2,"red"]]),g.forEach(([d,P])=>{t.strokeStyle=P,t.beginPath();let u=h;for(let y=0;y<=this.segments;y++){const w=o+(this.radius+d)*Math.cos(u),R=s+(this.radius+d)*Math.sin(u);u+=r,t.lineTo(...e.translate([w,R]))}t.stroke()})}}function A(i,t,e){return i<t?t:i>e?e:i}function H(i){return Math.sqrt(i[0]*i[0]+i[1]*i[1])}class q{constructor(){n(this,"eBrake",0);n(this,"throttle",0);n(this,"brake",0);n(this,"left",0);n(this,"right",0)}}function z(i){return{gravity:9.81,mass:1200,inertiaScale:1,halfWidth:.8,cgToFront:2,cgToRear:2,cgToFrontAxle:1.25,cgToRearAxle:1.25,cgHeight:.55,wheelRadius:.3,wheelWidth:.2,tireGrip:2,lockGrip:.7,engineForce:8e3,brakeForce:12e3,eBrakeForce:12e3/2.5,weightTransfer:.2,maxSteer:.6,cornerStiffnessFront:5,cornerStiffnessRear:5.2,airResist:2.5,rollResist:8,...i}}class V{constructor(t){n(this,"heading",0);n(this,"position",[0,0]);n(this,"velocity",[0,0]);n(this,"velocity_c",[0,0]);n(this,"accel",[0,0]);n(this,"accel_c",[0,0]);n(this,"absVel",0);n(this,"yawRate",0);n(this,"steer",0);n(this,"steerAngle",0);n(this,"input",new q);n(this,"smoothSteer",!0);n(this,"safeSteer",!0);n(this,"inertia",0);n(this,"wheelBase",0);n(this,"axleWeightRatioFront",0);n(this,"axleWeightRatioRear",0);n(this,"config",{});if(!t)throw"cade o config?";this.config=z(t),this.inertia=this.config.mass*this.config.inertiaScale,this.wheelBase=this.config.cgToFrontAxle+this.config.cgToRearAxle,this.axleWeightRatioFront=this.config.cgToRearAxle/this.wheelBase,this.axleWeightRatioRear=this.config.cgToFrontAxle/this.wheelBase;let e=this.config;console.log(-e.cgToRear,-e.halfWidth,e.cgToFront+e.cgToRear,e.halfWidth*2)}draw(t,e){const o=this.config;t.save(),t.translate(...e.translate(this.position)),t.rotate(this.heading),t.fillStyle="pink",t.scale(e.zoom,e.zoom),t.fillRect(-o.cgToRear,-o.halfWidth,o.cgToFront+o.cgToRear,o.halfWidth*2),t.restore(),t.fillStyle="black",t.fillText(`${this.absVel*3.6}km/h`,20,80)}update(t){this.doSteering();const e=this.config,o=Math.sin(this.heading),s=Math.cos(this.heading);this.velocity_c[0]=s*this.velocity[0]+o*this.velocity[1],this.velocity_c[1]=s*this.velocity[1]-o*this.velocity[0];const r=e.mass*(this.axleWeightRatioFront*e.gravity-e.weightTransfer*this.accel_c[0]*e.cgHeight/this.wheelBase),h=e.mass*(this.axleWeightRatioRear*e.gravity+e.weightTransfer*this.accel_c[0]*e.cgHeight/this.wheelBase),g=e.cgToFrontAxle*this.yawRate,d=-e.cgToRearAxle*this.yawRate,P=Math.atan2(this.velocity_c[1]+g,Math.abs(this.velocity_c[0]))-Math.sign(this.velocity_c[0])*this.steerAngle,u=Math.atan2(this.velocity_c[1]+d,Math.abs(this.velocity_c[0])),y=e.tireGrip,w=e.tireGrip*(1-this.input.eBrake*(1-e.lockGrip)),R=A(-e.cornerStiffnessFront*P,-y,y)*r,b=A(-e.cornerStiffnessRear*u,-w,w)*h,S=Math.min(this.input.brake*e.brakeForce+this.input.eBrake*e.eBrakeForce,e.brakeForce),F=this.input.throttle*e.engineForce,W=F-S*Math.sign(this.velocity_c[0]),T=0,B=-e.rollResist*this.velocity_c[0]-e.airResist*this.velocity_c[0]*Math.abs(this.velocity_c[0]),E=-e.rollResist*this.velocity_c[1]-e.airResist*this.velocity_c[1]*Math.abs(this.velocity_c[1]),L=B+W,Y=E+T+Math.cos(this.steerAngle)*R+b;this.accel_c[0]=L/e.mass,this.accel_c[1]=Y/e.mass,this.accel[0]=s*this.accel_c[0]-o*this.accel_c[1],this.accel[1]=o*this.accel_c[0]+s*this.accel_c[1],this.velocity[0]+=this.accel[0]*t,this.velocity[1]+=this.accel[1]*t,this.absVel=H(this.velocity);let I=(R+T)*e.cgToFrontAxle-b*e.cgToRearAxle;Math.abs(this.absVel)<.5&&!F&&(this.velocity[0]=this.velocity[1]=this.absVel=0,this.yawRate=I=0);const X=I/this.inertia;this.yawRate+=X*t,this.heading+=this.yawRate*t,this.position[0]+=this.velocity[0]*t,this.position[1]+=this.velocity[1]*t}doSteering(){const t=this.input.right-this.input.left;this.steer=t,this.steerAngle=this.steer*this.config.maxSteer}}const v=600,D=600;class ${constructor(){n(this,"x",0);n(this,"y",0);n(this,"zoom",20)}translate(t){return[(t[0]-this.x)*this.zoom+v/2,(t[1]-this.y)*this.zoom+v/2]}}const l=new $,_=[];for(let i=0;i<60;i++)_.push({radius:(2+Math.random()*10|0)*20,to:Math.random()-.5});let m;function K(){m=new x({center:[0,0],radius:50,from:0,to:-.5,width:10});let i=m;for(;_.length>0;)i=i.continue(_.pop());[l.x,l.y]=m.startPoint}function j(i){let t=m;for(;t;)t.draw(i,l),t=t.next;i.fillStyle="lime",i.beginPath(),i.moveTo(v/2,D/2),i.stroke()}const f={},a={oldX:0,oldY:0,x:0,y:0,speedX:0,speedY:0,button:[]},M=document.getElementById("myCanvas"),p=M.getContext("2d");p.font="14px serif";let c;function k(){p.clearRect(0,0,600,600),a.button[0]&&(l.x+=a.speedX,l.y+=a.speedY),c.input.left=0,c.input.right=0,f.a&&(c.input.left=1),f.d&&(c.input.right=1),c.input.throttle=0,c.input.brake=0,f.w&&(c.input.throttle=1),f.s&&(c.input.throttle=0,c.input.brake=1),j(p),p.fillText(`${a.x} ${a.y}`,20,20);let[i,t]=c.position,e=i-l.x,o=t-l.y;l.x+=e*.2,l.y+=o*.2,c.update(1e3/60/1e3),c.draw(p,l),requestAnimationFrame(k)}document.addEventListener("DOMContentLoaded",function(){c=new V({}),K(),c.position=m.startPoint,c.heading=-.5*Math.PI,k()});M.addEventListener("mousemove",function(i){const t=M.getBoundingClientRect();a.oldX=a.x,a.oldY=a.y,a.x=i.clientX-t.left,a.y=i.clientY-t.top,a.speedX=a.x-a.oldX,a.speedY=a.y-a.oldY});M.addEventListener("mousedown",function(i){a.button[i.button]=!0});M.addEventListener("mouseup",function(i){a.button[i.button]=!1});document.addEventListener("keydown",i=>{f[i.key]=!0});document.addEventListener("keyup",i=>{f[i.key]=!1});

</script>
</head>
<body>
    <canvas id="myCanvas" width="600" height="600" style="border:1px solid #000;"></canvas>
</body>
</html>
